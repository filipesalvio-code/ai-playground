import {
  Document,
  Packer,
  Paragraph,
  TextRun,
  HeadingLevel,
  AlignmentType,
  BorderStyle,
} from 'docx';

interface WordExportOptions {
  title?: string;
  author?: string;
}

/**
 * Export content to Word document
 */
export async function exportToWord(
  content: string,
  options: WordExportOptions = {}
): Promise<Blob> {
  const { title = 'AI Playground Export', author = 'AI Playground' } = options;

  // Parse content into paragraphs
  const paragraphs = content.split('\n\n').filter((p) => p.trim());

  const children: Paragraph[] = [
    // Title
    new Paragraph({
      children: [
        new TextRun({
          text: title,
          bold: true,
          size: 32,
        }),
      ],
      heading: HeadingLevel.HEADING_1,
      spacing: { after: 400 },
    }),
  ];

  // Add content paragraphs
  for (const para of paragraphs) {
    // Check if it's a heading (starts with # or all caps)
    if (para.startsWith('#')) {
      const level = para.match(/^#+/)?.[0].length || 1;
      const text = para.replace(/^#+\s*/, '');
      
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text,
              bold: true,
              size: 28 - (level * 2),
            }),
          ],
          heading: level === 1 ? HeadingLevel.HEADING_1 : 
                   level === 2 ? HeadingLevel.HEADING_2 : HeadingLevel.HEADING_3,
          spacing: { before: 300, after: 200 },
        })
      );
    } else if (para.startsWith('---')) {
      // Horizontal rule
      children.push(
        new Paragraph({
          border: {
            bottom: {
              color: 'auto',
              space: 1,
              style: BorderStyle.SINGLE,
              size: 6,
            },
          },
          spacing: { before: 200, after: 200 },
        })
      );
    } else {
      // Regular paragraph
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: para,
              size: 24,
            }),
          ],
          spacing: { after: 200 },
        })
      );
    }
  }

  // Add footer
  children.push(
    new Paragraph({
      children: [
        new TextRun({
          text: `Generated by ${author}`,
          size: 18,
          color: '888888',
          italics: true,
        }),
      ],
      alignment: AlignmentType.RIGHT,
      spacing: { before: 400 },
    })
  );

  const doc = new Document({
    creator: author,
    title: title,
    description: 'Exported from AI Playground',
    sections: [
      {
        children,
      },
    ],
  });

  const buffer = await Packer.toBuffer(doc);
  const uint8Array = new Uint8Array(buffer);
  return new Blob([uint8Array], {
    type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  });
}

/**
 * Export conversation to Word
 */
export async function exportConversationToWord(
  messages: { role: string; content: string }[],
  title?: string
): Promise<Blob> {
  const children: Paragraph[] = [
    new Paragraph({
      children: [
        new TextRun({
          text: title || 'Chat Conversation',
          bold: true,
          size: 32,
        }),
      ],
      heading: HeadingLevel.HEADING_1,
      spacing: { after: 400 },
    }),
  ];

  for (const msg of messages) {
    // Role header
    children.push(
      new Paragraph({
        children: [
          new TextRun({
            text: msg.role.toUpperCase(),
            bold: true,
            size: 22,
            color: msg.role === 'user' ? '00f0ff' : 'ff3366',
          }),
        ],
        spacing: { before: 300 },
      })
    );

    // Message content
    children.push(
      new Paragraph({
        children: [
          new TextRun({
            text: msg.content,
            size: 24,
          }),
        ],
        spacing: { after: 200 },
      })
    );
  }

  const doc = new Document({
    creator: 'AI Playground',
    title: title || 'Chat Conversation',
    sections: [{ children }],
  });

  const buffer = await Packer.toBuffer(doc);
  const uint8Array = new Uint8Array(buffer);
  return new Blob([uint8Array], {
    type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  });
}

