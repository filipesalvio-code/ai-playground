import PptxGenJS from 'pptxgenjs';

interface PptExportOptions {
  title?: string;
  author?: string;
  theme?: {
    background: string;
    titleColor: string;
    textColor: string;
    accentColor: string;
  };
}

const DEFAULT_THEME = {
  background: '0a0f1a',
  titleColor: '00f0ff',
  textColor: 'ffffff',
  accentColor: 'ff3366',
};

/**
 * Export content to PowerPoint presentation
 */
export async function exportToPpt(
  slides: { title: string; content: string }[],
  options: PptExportOptions = {}
): Promise<Blob> {
  const { 
    title = 'AI Playground Presentation', 
    author = 'AI Playground',
    theme = DEFAULT_THEME,
  } = options;

  const pptx = new PptxGenJS();
  
  pptx.author = author;
  pptx.title = title;
  pptx.subject = 'Generated by AI Playground';

  // Define master slide
  pptx.defineSlideMaster({
    title: 'AI_MASTER',
    background: { color: theme.background },
  });

  // Title slide
  const titleSlide = pptx.addSlide({ masterName: 'AI_MASTER' });
  titleSlide.addText(title, {
    x: 0.5,
    y: 2.5,
    w: '90%',
    fontSize: 44,
    bold: true,
    color: theme.titleColor,
    align: 'center',
  });
  titleSlide.addText(`Generated by ${author}`, {
    x: 0.5,
    y: 4.5,
    w: '90%',
    fontSize: 18,
    color: theme.textColor,
    align: 'center',
  });

  // Content slides
  for (const slide of slides) {
    const contentSlide = pptx.addSlide({ masterName: 'AI_MASTER' });
    
    // Title
    contentSlide.addText(slide.title, {
      x: 0.5,
      y: 0.5,
      w: '90%',
      fontSize: 32,
      bold: true,
      color: theme.titleColor,
    });

    // Content (split into bullet points if needed)
    const lines = slide.content.split('\n').filter((l) => l.trim());
    const bullets = lines.map((line) => ({
      text: line.replace(/^[-â€¢]\s*/, ''),
      options: {
        bullet: { type: 'bullet' as const },
        color: theme.textColor,
        fontSize: 18,
      },
    }));

    if (bullets.length > 0) {
      contentSlide.addText(bullets, {
        x: 0.5,
        y: 1.5,
        w: '90%',
        h: 4,
        valign: 'top',
      });
    }
  }

  // Generate blob
  const data = await pptx.write({ outputType: 'blob' });
  return data as Blob;
}

/**
 * Export conversation to PowerPoint
 */
export async function exportConversationToPpt(
  messages: { role: string; content: string }[],
  title?: string
): Promise<Blob> {
  // Group messages into slides (combine short exchanges)
  const slides: { title: string; content: string }[] = [];
  
  for (let i = 0; i < messages.length; i += 2) {
    const userMsg = messages[i];
    const assistantMsg = messages[i + 1];
    
    if (userMsg) {
      const slideTitle = userMsg.content.slice(0, 50) + (userMsg.content.length > 50 ? '...' : '');
      let content = '';
      
      if (assistantMsg) {
        // Truncate long responses
        content = assistantMsg.content.slice(0, 500);
        if (assistantMsg.content.length > 500) {
          content += '\n\n[Content truncated for presentation]';
        }
      }
      
      slides.push({ title: slideTitle, content });
    }
  }

  return exportToPpt(slides, { title: title || 'Chat Conversation' });
}

/**
 * Export research to PowerPoint
 */
export async function exportResearchToPpt(
  question: string,
  synthesis: string,
  citations?: { title: string; url: string }[]
): Promise<Blob> {
  const slides: { title: string; content: string }[] = [
    {
      title: 'Research Question',
      content: question,
    },
  ];

  // Split synthesis into multiple slides if too long
  const paragraphs = synthesis.split('\n\n').filter((p) => p.trim());
  const maxCharsPerSlide = 400;
  let currentSlide = { title: 'Key Findings', content: '' };

  for (const para of paragraphs) {
    if ((currentSlide.content + para).length > maxCharsPerSlide && currentSlide.content) {
      slides.push(currentSlide);
      currentSlide = { title: 'Key Findings (continued)', content: para + '\n\n' };
    } else {
      currentSlide.content += para + '\n\n';
    }
  }
  
  if (currentSlide.content) {
    slides.push(currentSlide);
  }

  // Sources slide
  if (citations && citations.length > 0) {
    slides.push({
      title: 'Sources',
      content: citations.map((c, i) => `${i + 1}. ${c.title}`).join('\n'),
    });
  }

  return exportToPpt(slides, { title: 'Research Report' });
}

